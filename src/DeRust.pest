// moudle 至少一个的话, 应该怎么区分, lib? 函数? main函数入口? 还是什么
file = { SOI ~ module* ~ EOI }
// TODO: comment 以何种方式. 其他的module.
module = { def_fn | def_fn_main }

def_fn_main = { KEYWORD_def_fn_start ~ DOT? ~ "main" ~ "(" ~ ")" ~ fn_type? ~ block }
    KEYWORD_def_fn_start = _{ "fn" }
def_fn = { KEYWORD_def_fn_start ~ DOT? ~ fn_def_identifier ~ fn_type? ~ block }
    fn_def_identifier = { fn_def_identifier_2plus | fn_def_identifier_1 }
        fn_def_identifier_1 = { identifier ~ "(" ~ ( ","? ~ type_expr ~ ( "," ~ type_expr )* ~ ","? )? ~ ")" }
        fn_def_identifier_2plus = {
              identifier
            ~ ( "(" ~ ( ","? ~ type_expr ~ ( "," ~ type_expr )* ~ ","? )
              ~ ")" ~ identifier_atomic +
              )+
            ~ ( "(" ~ ( ","? ~ type_expr ~ ( "," ~ type_expr )* ~ ","? 
                      )?
              ~ ")"
              )?
        }
    fn_type = { "->" ~ type_name }
        type_name = { identifier
            /* /* | */ // TODO 其他enum: (<i32>,<i32>) [<i32>]  */
            // TODO: type tuple_type or_type ...
        }

block = { block_expr | block_statement }
    block_statement = { "{" ~ statement* ~ block_return_statement? ~ "}" }
    block_expr = { "{" ~ statement* ~ ( expression | block_return_expr ) ~ "}" }
        block_return_expr = { KEYWORD_return ~ DOT? ~ expression ~ ";"? }
        block_return_statement = { KEYWORD_return ~ DOT? ~ ";"? }
        KEYWORD_return = _{ "return" }

statement = { function_call_statement
    /* | let_statement */
    // TODO
}
expression = {
      brackt_expr | tuple_expr
    | branch_expr | loop_expr
    | array_expr
    | lambda_expr
    | function_call_expr
    | literal_expr | identifier
    /* | method_call_expr                   */
    /* | binary_expr                        */
    /* | unary_expr // 一元操作         */
    /* | cast_expr  // foo as f64           */
    /* | let_expr                           */
    /* | block_expr // 同上               */
    /* | async await                        */
    /* | try_block_expr                     */
    /* | assign                             */
    /* | assign_op // a += 1                */
    /* | field_expr // obj.foo obj.0        */
    /* | index_expr // list[2]              */
    /* | range_expr // 1..2                 */
    /* | underscore_expr // 单下划线    */
    /* | path // TODO: 不明白            */
    /* | addrof // &a &mut a                */
    /* | break_expr                         */
    /* | continue_expr // 要不要呢      */
    /* | inlineasm maccall // ?             */
    /* | struct_expr // Foo {x: 1, y: 2}    */
    /* | repeat_expr // [1; 5]              */
    /* | paren_expr // ("123")              */
    /* | try_expr // expr?                  */
    /* | yeet // ?                          */
    /* | includedbytes // ?                 */
    /* | formatargs // format_args!()       */
    /* | Err_expr                           */
    // TODO
}
    brackt_expr = { "(" ~ expression ~ ")" }
    tuple_expr  = { "(" ~ ","? ~ expression ~ ("," ~ expression)+ ~ ","? ~")" }

    loop_expr = { loop_for_expr | loop_while_expr | loop_times_expr }
        loop_for_expr = { KEYWORD_loop_for ~ DOT?
            ~ ( "(" ~identifier ~ ")" ~ DOT? | identifier ~ DOT ) ~ KEYWORD_in ~ DOT? ~ expression ~ block_expr }
        loop_while_expr = { KEYWORD_loop_while ~ DOT? ~ expression ~ block_expr }
        loop_times_expr = { KEYWORD_loop ~ DOT?
            ~ ( ( "(" ~ expression ~ ")" ~ DOT? | expression ~ DOT ) ~ KEYWORD_times)?
            ~ block_expr }
            KEYWORD_loop_for = _{ "loop"? ~ "for" }
            KEYWORD_in = _{ "in" }
            KEYWORD_loop = _{ "loop" }
            KEYWORD_times = _{ "times" | "time" }
            KEYWORD_loop_while = _{ "loop"? ~ "while" }

    function_call_expr = {
          ( identifier
          ~ ( "(" ~ ( ","? ~ expression ~ ( "," ~ expression )* ~ ","?
                    )?
            ~ ")" ~ identifier_atomic +
            )+
          ~ ( "(" ~ ( ","? ~ expression ~ ( "," ~ expression )* ~ ","?
                    )?
            ~ ")"
            )?
          )
        | ( identifier
          ~ "(" ~ ( ","? ~ expression ~ ( "," ~ expression )* ~ ","?
                  )?
          ~ ")"
          )
    }

    literal_expr   = { bool_literal | measure_with_number | number_literal | string_literal }
        bool_literal = { "true" | "false" }
        string_literal = { triple_quote_string | quote_string | raw_string }
            quote_string = ${ PUSH("\"") ~ inner_string ~ POP }
            raw_string   = ${ "r" ~ PUSH("#"*) ~ "\"" ~ inner_string ~ "\"" ~ POP }
            triple_quote_string     = ${ PUSH("\"\"\"") ~ NEWLINE ~ inner_string ~ POP }
                inner_string = ${ (!(PEEK) ~ ANY)* }
        number_literal = { number_with_underline | number_with_space | number_pure }
            number_with_underline = @{ ( NUMBER+ ~ "_"{1, 3} )+ ~ (NUMBER+)?
                | ( "_"{1, 3} ~ NUMBER+ )+ ~ "_"{, 3} }
            number_with_space =     @{ NUMBER+ ~ (" "{1, 3} ~ NUMBER+)+ }
        measure_with_number = ${ number_literal ~ " "{,3} ~ LETTER+ }
    array_expr = { array_repeat | array_some | array_none }
    branch_expr = { match_expr | if_expr }
        if_expr = { if_expr_rust | if_expr_derust }
                KEYWORD_if = _{ "if" }
                KEYWORD_else_if = _{ "else" ~ "if" }
                KEYWORD_else = _{ "else" }
                KEYWORD_when = _{ "when" }
                MARK_branch = _{ "," | "|" }
            if_expr_rust = { sub_if_expr ~ sub_else_if_expr* ~ sub_else_expr? }
                sub_if_expr = { KEYWORD_if ~ DOT? ~ expression ~ block_expr }
                sub_else_if_expr = { KEYWORD_else_if ~ DOT? ~ expression ~ block_expr }
                sub_else_expr = { KEYWORD_else ~ block_expr }
            if_expr_derust = { KEYWORD_if ~ "{" ~ MARK_branch? ~ if_branch ~ ( MARK_branch ~ else_if_branch )*
                ~ ( MARK_branch? ~ "}" ~ else_branch | MARK_branch? ~ "}" | ( MARK_branch ~ else_branch )? ~ "}" ) }
                if_branch = { expression ~ block_expr }
                else_if_branch = { expression ~ block_expr }
                else_branch = { KEYWORD_else ~ block_expr }
            // TODO when表达式
            /* if_expr_when = { expression ~ DOT ~ KEYWORD_when ~ DOT? ~ expression */
            /*     ~ ( DOT ~ KEYWORD_else ~ ( expression | block_expr ) )? }        */
        match_expr = { match_expr_rust | match_expr_derust }
            match_expr_rust = { KEYWORD_match ~ DOT? ~ expression ~ match_branches_expr }
            match_expr_derust = { KEYWORD_if ~ DOT?
                ~ ( "(" ~ expression ~ ")" ~ DOT? | expression ~ DOT )
                ~ KEYWORD_is ~ match_branches_expr }
                match_branches_expr = { "{" ~ MARK_branch? ~ match_branch_expr ~ ( MARK_branch ~ match_branch_expr )*
                    ~ ( MARK_branch? ~ "}" ~ match_branch_else_expr?
                        | MARK_branch ~ ( match_branch_else_expr | underline_branch ) ~ "}" )
                        | match_branch_expr ~ match_branch_else_expr? }
                    // TODO: match 的参数, 是不是有限制.
                match_branch_expr = { expression ~ block_expr }
                underline_branch = { "_" ~ block_expr }
                match_branch_else_expr = { KEYWORD_else ~ block_expr }
                KEYWORD_match = _{ "match" }
                KEYWORD_is = _{ "is" }



//  直接返回 pair.as_str() 的规则
WHITESPACE   = _{ " " | "\t" | NEWLINE | comment}
array_none = { "[" ~ "]" }



function_call_statement = { function_call_expr ~ ";" }
type_expr               = { identifier ~ ":" ~ type_name }
array_repeat = { "[" ~ expression ~ ";" ~ number_literal ~ "]" }
lambda_expr = { KEYWORD_lambda_start ~ lambda_head ~ block_expr }

// 具有不固定数量同样子规则的规则, 用 for subpair in pair.into_inner() 解析
array_some = { "[" ~ ","? ~ expression ~ ("," ~ expression)* ~ ","? ~ "]" }
lambda_head = { "(" ~ (type_expr ~ ","?)* ~ ")" }

// silent
KEYWORD_lambda_start = _{ "fn" }
DOT                  = _{ "." }
line_comment         = _{ ("//" ~ !("/" | "!") ~ (!NEWLINE ~ ANY)*) }
block_comment        = _{ "/*" ~ (block_comment | !"*/" ~ ANY)* ~ "*/" }
comment              = _{ block_comment | line_comment }

// 原子规则
KEYWORD = @{
        "abstract" | "as" | "become" | "break" | "byte" | "class" | "clear" |
        "const" | "continue" | "do" | "else" | "enum" | "eval" | "export" |
        "extern" | "false" | "final" | "fn" | "for" | "if" | "impl" | "import" |
        "in" | "let" | "loop" | "main" | "match" | "mod" | "move" | "mut" | "of" |
        "out" | "pub" | "raw" | "ref" | "return" | "self" | "static" |
        "struct" | "super" | "trait" | "true" | "typeof" | "type" | "unsafe" |
        "use" | "where" | "while" | "yield"
}


// 变量不能以数字或者下划线+数字开头
identifier = ${ !( KEYWORD | ("_"* ~ NUMBER) ) ~ identifier_atomic ~ ( " " ~ identifier_atomic )*
    | "(" ~ identifier ~ ")" }
brackt_identifier = { "(" ~ ","? ~ identifier ~ ")" }
// TODO: 这个 rule 运行的时候并不如设想的那样是 silent, 可能有bug
// 添加unicode字符
identifier_atomic = ${ ( "_"* ~ (LETTER | NUMBER)+ ~ "_"* )+ }

number_pure = @{ NUMBER+ }
