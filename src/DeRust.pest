loop_expr = { loop_for_expr | loop_while_expr | loop_times_expr }

loop_for_expr = { keyword_loop_for ~ loop_for_parameter ~ block_expr }
keyword_loop_for = _{ "loop"? ~ "for" }
keyword_in = _{ "in" }
loop_for_parameter = { loop_for_identifier ~ keyword_in ~ loop_for_iter
    | identifier_except_in ~ keyword_in ~ expression }
loop_for_identifier = { DOT ~ identifier ~ DOT | DOT? ~ "(" ~ identifier ~ ")" ~ DOT? }
loop_for_iter = { DOT ~ expression | DOT? ~ "(" ~ expression ~ ")" }
/* except_in_expr = { identifier_except_in | function_call_expr_except_in } */

loop_while_expr = { keyword_loop_while ~ loop_while_condition ~ block_expr }
keyword_loop_while = _{ "loop"? ~ "while" }
loop_while_condition = { DOT ~ expression | DOT? ~ "(" ~ expression ~ ")" }

loop_times_expr = { keyword_loop ~ ( loop_times_parameter ~ keyword_times )? ~ block_expr }
keyword_loop = _{ "loop" }
loop_times_parameter = { DOT ~ expression ~ DOT | DOT? ~ "(" ~ expression ~ ")" ~ DOT? | number_literal }
keyword_times = _{ "times" | "time" }

def_fn_head = {
      ( ( identifier
          ~ ( "(" ~ ( ","? ~ type_expr ~ ( "," ~ type_expr )* ~ ","? )
            ~ ")" ~ identifier_atomic +
            )+
          ~ ( "(" ~ ( ","? ~ type_expr ~ ( "," ~ type_expr )* ~ ","? 
                    )?
            ~ ")"
            )?
        )
      | ( identifier
        ~ "(" ~ ( ","? ~ type_expr ~ ( "," ~ type_expr )* ~ ","?
                )?
        ~ ")"
      ) )
    ~ ( "->" ~ type_name )?
}

// TODO: 考虑加入这样的形式: f [1, 2, 3] f ()
// 就是说, 如果参数是一个数组, 圆括号可以省略.
// map (array) by { |x|
//    x * 3
// }
// 考虑函数作为参数的情况.
function_call_expr = {
      ( identifier
      ~ ( "(" ~ ( ","? ~ expression ~ ( "," ~ expression )* ~ ","?
                )?
        ~ ")" ~ identifier_atomic +
        )+
      ~ ( "(" ~ ( ","? ~ expression ~ ( "," ~ expression )* ~ ","?
                )?
        ~ ")"
        )?
      )
    | ( identifier
      ~ "(" ~ ( ","? ~ expression ~ ( "," ~ expression )* ~ ","?
              )?
      ~ ")"
      )
}
function_call_expr_except_in = {
      ( identifier_except_in
      ~ ( "(" ~ ( ","? ~ expression ~ ( "," ~ expression )* ~ ","?
                )?
        ~ ")" ~ identifier_atomic_except_in +
        )+
      ~ ( "(" ~ ( ","? ~ expression ~ ( "," ~ expression )* ~ ","?
                )?
        ~ ")"
        )?
      )
    | ( identifier_except_in
      ~ "(" ~ ( ","? ~ expression ~ ( "," ~ expression )* ~ ","?
              )?
      ~ ")"
      )
}

// enum
statement = { function_call_statement
    /* | let_statement */
    // TODO
}
expression = { function_call_expr | type_expr | expr_literal | tuple_expr | identifier
    | array_expr
    | lambda_expr
    /* | method_call_expr                   */
    /* | binary_expr                        */
    /* | unary_expr // 一元操作         */
    /* | cast_expr  // foo as f64           */
    /* | let_expr                           */
    | if_expr
    | loop_expr  // TODO: while for loop
    | brackt_expr // 为了解析多余的括号
    /* | match_expr                         */
    /* | block_expr // 同上               */
    /* | async await                        */
    /* | try_block_expr                     */
    /* | assign                             */
    /* | assign_op // a += 1                */
    /* | field_expr // obj.foo obj.0        */
    /* | index_expr // list[2]              */
    /* | range_expr // 1..2                 */
    /* | underscore_expr // 单下划线    */
    /* | path // TODO: 不明白            */
    /* | addrof // &a &mut a                */
    /* | break_expr                         */
    /* | continue_expr // 要不要呢      */
    /* | ret_expr // return abc             */
    /* | inlineasm maccall // ?             */
    /* | struct_expr // Foo {x: 1, y: 2}    */
    /* | repeat_expr // [1; 5]              */
    /* | paren_expr // ("123")              */
    /* | try_expr // expr?                  */
    /* | yeet // ?                          */
    /* | includedbytes // ?                 */
    /* | formatargs // format_args!()       */
    /* | Err_expr                           */
    // TODO
}
type_name = { identifier
    /* /* | */ // TODO 其他enum: (<i32>,<i32>) [<i32>]  */
    // TODO: type tuple_type or_type ...
}
expr_literal   = { bool_literal | measure_with_number | number_literal | string_literal }
string_literal = { triple_quote_string | quote_string | raw_string }
array_expr = { array_repeat | array_some | array_none }

if_expr = { sub_if_expr ~ sub_else_if_expr* ~ sub_else_expr? }
sub_if_expr = { keyword_if ~ if_parameter ~ block_expr }
sub_else_if_expr = { keyword_else_if ~ if_parameter ~ block_expr }
sub_else_expr = { keyword_else ~ block_expr }

if_parameter = { DOT? ~ "(" ~ expression ~ ")" | DOT ~ expression }
block_expr = { "{" ~ statement* ~ expression ~ "}" }
keyword_if = _{ "if" }
keyword_else_if = _{ "else" ~ "if" }
keyword_else = _{ "else" }

//  直接返回 pair.as_str() 的规则
bool_literal = { "true" | "false" }
inner_string = ${ (!(PEEK) ~ ANY)* }
quote_string = ${ PUSH("\"") ~ inner_string ~ POP }
raw_string   = ${ "r" ~ PUSH("#"*) ~ "\"" ~ inner_string ~ "\"" ~ POP }
WHITESPACE   = _{ " " | "\t" | NEWLINE | comment}
array_none = { "[" ~ "]" }

// 直接对 pair.as_str() 处理的规则
number_literal = { number_with_underline | number_with_space | number_pure }

// 具有固定数量子规则的规则, 用 inner_rules.next().unwrap() 解析.
def_fn                  = { keyword_def_fn_start ~ DOT ~ def_fn_head ~ fn_body }
function_call_statement = { function_call_expr ~ ";" }
triple_quote_string     = ${ PUSH("\"\"\"") ~ NEWLINE ~ inner_string ~ POP }
brackt_expr = ${ "(" ~ expression ~ ")" }
type_expr               = { identifier ~ ":" ~ type_name }
array_repeat = { "[" ~ expression ~ ";" ~ number_literal ~ "]" }
lambda_expr = { keyword_lambda_start ~ lambda_head ~ fn_body }

// 具有不固定数量同样子规则的规则, 用 for subpair in pair.into_inner() 解析
array_some = { "[" ~ ","? ~ expression ~ ("," ~ expression)* ~ ","? ~ "]" }
fn_body = { "{" ~ statement* ~ expression? ~ "}" }
tuple_expr  = { "(" ~  expression ~ ("," ~ expression)+ ~ ","? ~")" }
file = { SOI ~ ( def_fn
      /* | comment */
    // TODO: 其他模块
      )* ~ EOI }
lambda_head = { "(" ~ (type_expr ~ ","?)* ~ ")" }

// silent
keyword_def_fn_start = _{ "fn" }
keyword_lambda_start = _{ "fn" }
DOT                  = _{ "." }
line_comment         = _{ ("//" ~ !("/" | "!") ~ (!NEWLINE ~ ANY)*) }
block_comment        = _{ "/*" ~ (block_comment | !"*/" ~ ANY)* ~ "*/" }
comment              = _{ block_comment | line_comment }

// 原子规则
keyword = @{
        "abstract" | "as" | "become" | "break" | "byte" | "class" | "clear" |
        "const" | "continue" | "do" | "else" | "enum" | "eval" | "export" |
        "extern" | "false" | "final" | "fn" | "for" | "if" | "impl" | "import" |
        "in" | "let" | "loop" | "match" | "mod" | "move" | "mut" | "of" |
        "out" | "pub" | "raw" | "ref" | "return" | "self" | "static" |
        "struct" | "super" | "trait" | "true" | "typeof" | "type" | "unsafe" |
        "use" | "where" | "while" | "yield"
}

number_with_underline = @{ ( NUMBER+ ~ "_"{1, 3} )+ ~ (NUMBER+)?
    | ( "_"{1, 3} ~ NUMBER+ )+ ~ "_"{, 3} }
number_with_space =     @{ NUMBER+ ~ (" "{1, 3} ~ NUMBER+)+ }
number_pure = @{ NUMBER+ }

measure_with_number = ${ number_literal ~ " "{,3} ~ LETTER+ }
// 变量不能以数字或者下划线+数字开头
identifier = ${ !( keyword | ("_"* ~ NUMBER) ) ~ identifier_atomic ~ ( " " ~ identifier_atomic )* }
// TODO: 这个 rule 运行的时候并不如设想的那样是 silent, 可能有bug
// 添加unicode字符
identifier_atomic = ${ ( "_"* ~ (LETTER | NUMBER)+ ~ "_"* )+ }

identifier_atomic_except_in = ${ !"in" ~ ( "_"* ~ (LETTER | NUMBER)+ ~ "_"* )+ }
identifier_except_in = ${ !( keyword | ("_"* ~ NUMBER) )
    ~ identifier_atomic_except_in ~ ( " " ~ identifier_atomic_except_in )* }
