loop_expr = { loop_for_expr | loop_while_expr | loop_times_expr }

loop_for_expr = { KEYWORD_loop_for ~ DOT?
    ~ ( "(" ~identifier ~ ")" ~ DOT? | identifier ~ DOT ) ~ KEYWORD_in ~ DOT? ~ expression ~ block_expr }
KEYWORD_loop_for = _{ "loop"? ~ "for" }
KEYWORD_in = _{ "in" }

loop_while_expr = { KEYWORD_loop_while ~ DOT? ~ expression ~ block_expr }
KEYWORD_loop_while = _{ "loop"? ~ "while" }

loop_times_expr = { KEYWORD_loop ~ DOT?
    ~ ( ( "(" ~ expression ~ ")" ~ DOT? | expression ~ DOT ) ~ KEYWORD_times
      )?
    ~ block_expr
}
KEYWORD_loop = _{ "loop" }
KEYWORD_times = _{ "times" | "time" }

def_fn_head = {
      ( ( identifier
          ~ ( "(" ~ ( ","? ~ type_expr ~ ( "," ~ type_expr )* ~ ","? )
            ~ ")" ~ identifier_atomic +
            )+
          ~ ( "(" ~ ( ","? ~ type_expr ~ ( "," ~ type_expr )* ~ ","? 
                    )?
            ~ ")"
            )?
        )
      | ( identifier
        ~ "(" ~ ( ","? ~ type_expr ~ ( "," ~ type_expr )* ~ ","?
                )?
        ~ ")"
      ) )
    ~ ( "->" ~ type_name )?
}

// TODO: 考虑加入这样的形式: f [1, 2, 3] f ()
// 就是说, 如果参数是一个数组, 圆括号可以省略.
// map (array) by { |x|
//    x * 3
// }
// 考虑函数作为参数的情况.
function_call_expr = {
      ( identifier
      ~ ( "(" ~ ( ","? ~ expression ~ ( "," ~ expression )* ~ ","?
                )?
        ~ ")" ~ identifier_atomic +
        )+
      ~ ( "(" ~ ( ","? ~ expression ~ ( "," ~ expression )* ~ ","?
                )?
        ~ ")"
        )?
      )
    | ( identifier
      ~ "(" ~ ( ","? ~ expression ~ ( "," ~ expression )* ~ ","?
              )?
      ~ ")"
      )
}

// enum
statement = { function_call_statement
    /* | let_statement */
    // TODO
}
expression = { function_call_expr | type_expr | expr_literal | tuple_expr | identifier
    | array_expr
    | lambda_expr
    /* | method_call_expr                   */
    /* | binary_expr                        */
    /* | unary_expr // 一元操作         */
    /* | cast_expr  // foo as f64           */
    /* | let_expr                           */
    | if_expr
    | loop_expr  // TODO: while for loop
    | match_expr
    /* | block_expr // 同上               */
    /* | async await                        */
    /* | try_block_expr                     */
    /* | assign                             */
    /* | assign_op // a += 1                */
    /* | field_expr // obj.foo obj.0        */
    /* | index_expr // list[2]              */
    /* | range_expr // 1..2                 */
    /* | underscore_expr // 单下划线    */
    /* | path // TODO: 不明白            */
    /* | addrof // &a &mut a                */
    /* | break_expr                         */
    /* | continue_expr // 要不要呢      */
    /* | ret_expr // return abc             */
    /* | inlineasm maccall // ?             */
    /* | struct_expr // Foo {x: 1, y: 2}    */
    /* | repeat_expr // [1; 5]              */
    /* | paren_expr // ("123")              */
    /* | try_expr // expr?                  */
    /* | yeet // ?                          */
    /* | includedbytes // ?                 */
    /* | formatargs // format_args!()       */
    /* | Err_expr                           */
    | brackt_expr // 为了解析多余的括号
    // TODO
}
brackt_expr = { "(" ~ ","? ~ expression ~ ")" }

type_name = { identifier
    /* /* | */ // TODO 其他enum: (<i32>,<i32>) [<i32>]  */
    // TODO: type tuple_type or_type ...
}
expr_literal   = { bool_literal | measure_with_number | number_literal | string_literal }
string_literal = { triple_quote_string | quote_string | raw_string }
array_expr = { array_repeat | array_some | array_none }

if_expr = { if_expr_rust | if_expr_derust }
        KEYWORD_if = _{ "if" }
        KEYWORD_else_if = _{ "else" ~ "if" }
        KEYWORD_else = _{ "else" }
        MARK_branch = _{ "," | "|" }
    if_expr_rust = { sub_if_expr ~ sub_else_if_expr* ~ sub_else_expr? }
        sub_if_expr = { KEYWORD_if ~ DOT? ~ expression ~ block_expr }
        sub_else_if_expr = { KEYWORD_else_if ~ DOT? ~ expression ~ block_expr }
        sub_else_expr = { KEYWORD_else ~ block_expr }
    if_expr_derust = { KEYWORD_if ~ "(" ~ MARK_branch? ~ if_branch ~ ( MARK_branch ~ else_if_branch )*
        ~ ( MARK_branch? ~ ")" ~ else_branch | MARK_branch? ~ ")" | ( MARK_branch ~ else_branch )? ~ ")" ) }
        if_branch = { expression ~ block_expr }
        else_if_branch = { expression ~ block_expr }
        else_branch = { KEYWORD_else ~ block_expr }

match_expr = { KEYWORD_if ~ DOT? ~ ( expression ~ DOT | "(" ~ expression ~ ")" ~ DOT? )
    ~ KEYWORD_is ~ DOT? ~ match_branches_expr }
    match_branches_expr = { "(" ~ MARK_branch? ~ match_branch_expr ~ ( MARK_branch ~ match_branch_expr )*
        ~ ( MARK_branch? ~ ")" ~ match_branch_else_expr? | MARK_branch ~ match_branch_else_expr ~ ")" )
        | match_branch_expr ~ match_branch_else_expr? }
        // TODO: match 的参数, 是不是有限制.
        match_branch_expr = { expression ~ block_expr }
        match_branch_else_expr = { KEYWORD_else ~ block_expr }
    KEYWORD_is = _ { "is" }

block_expr = { "{" ~ statement* ~ expression ~ "}" }

//  直接返回 pair.as_str() 的规则
bool_literal = { "true" | "false" }
inner_string = ${ (!(PEEK) ~ ANY)* }
quote_string = ${ PUSH("\"") ~ inner_string ~ POP }
raw_string   = ${ "r" ~ PUSH("#"*) ~ "\"" ~ inner_string ~ "\"" ~ POP }
WHITESPACE   = _{ " " | "\t" | NEWLINE | comment}
array_none = { "[" ~ "]" }

// 直接对 pair.as_str() 处理的规则
number_literal = { number_with_underline | number_with_space | number_pure }

// 具有固定数量子规则的规则, 用 inner_rules.next().unwrap() 解析.
def_fn                  = { KEYWORD_def_fn_start ~ DOT? ~ def_fn_head ~ DOT? ~ fn_body }
function_call_statement = { function_call_expr ~ ";" }
triple_quote_string     = ${ PUSH("\"\"\"") ~ NEWLINE ~ inner_string ~ POP }
type_expr               = { identifier ~ ":" ~ type_name }
array_repeat = { "[" ~ expression ~ ";" ~ number_literal ~ "]" }
lambda_expr = { KEYWORD_lambda_start ~ lambda_head ~ fn_body }

// 具有不固定数量同样子规则的规则, 用 for subpair in pair.into_inner() 解析
array_some = { "[" ~ ","? ~ expression ~ ("," ~ expression)* ~ ","? ~ "]" }
fn_body = { "{" ~ statement* ~ expression? ~ "}" }
tuple_expr  = { "(" ~ ","? ~ expression ~ ("," ~ expression)+ ~ ","? ~")" }
file = { SOI ~ ( def_fn
      /* | comment */
    // TODO: 其他模块
      )* ~ EOI }
lambda_head = { "(" ~ (type_expr ~ ","?)* ~ ")" }

// silent
KEYWORD_def_fn_start = _{ "fn" }
KEYWORD_lambda_start = _{ "fn" }
DOT                  = _{ "." }
line_comment         = _{ ("//" ~ !("/" | "!") ~ (!NEWLINE ~ ANY)*) }
block_comment        = _{ "/*" ~ (block_comment | !"*/" ~ ANY)* ~ "*/" }
comment              = _{ block_comment | line_comment }

// 原子规则
KEYWORD = @{
        "abstract" | "as" | "become" | "break" | "byte" | "class" | "clear" |
        "const" | "continue" | "do" | "else" | "enum" | "eval" | "export" |
        "extern" | "false" | "final" | "fn" | "for" | "if" | "impl" | "import" |
        "in" | "let" | "loop" | "match" | "mod" | "move" | "mut" | "of" |
        "out" | "pub" | "raw" | "ref" | "return" | "self" | "static" |
        "struct" | "super" | "trait" | "true" | "typeof" | "type" | "unsafe" |
        "use" | "where" | "while" | "yield"
}

number_with_underline = @{ ( NUMBER+ ~ "_"{1, 3} )+ ~ (NUMBER+)?
    | ( "_"{1, 3} ~ NUMBER+ )+ ~ "_"{, 3} }
number_with_space =     @{ NUMBER+ ~ (" "{1, 3} ~ NUMBER+)+ }

measure_with_number = ${ number_literal ~ " "{,3} ~ LETTER+ }
// 变量不能以数字或者下划线+数字开头
identifier = ${ !( KEYWORD | ("_"* ~ NUMBER) ) ~ identifier_atomic ~ ( " " ~ identifier_atomic )*
    | "(" ~ identifier ~ ")" }
brackt_identifier = { "(" ~ ","? ~ identifier ~ ")" }
// TODO: 这个 rule 运行的时候并不如设想的那样是 silent, 可能有bug
// 添加unicode字符
identifier_atomic = ${ ( "_"* ~ (LETTER | NUMBER)+ ~ "_"* )+ }

number_pure = @{ NUMBER+ }
